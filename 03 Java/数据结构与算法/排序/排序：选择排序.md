# 排序：选择排序

[TOC]

## 1、原理

首先找到数组中最小的元素，

然后，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么就和自己交换)，

之后，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置，

如此往复，直到将整个数组排序。

因为它在不断地选择剩余元素中地最小者。所以叫选择排序。

## 2、过程

int[] arr = {6,2,8,4,1,7};

第一次选择：min = 6，依次和 {2,8,4,1,7} 比较，选出最小者 1，交换，{1,2,8,4,6,7}

第二次选择：min = 2，依次和 {8,4,6,7} 比较，选出最小者2，和自己交换，{1,2,8,4,6,7}

第三次选择：min = 8，依次和 {4,6,7} 比较，选出最小者4，交换，{1,2,4,8,6,7}

第四次选择：min = 8，依次和 {6,7} 比较，选出最小者6，交换，{1,2,4,6,8,7}

第五次选择：min = 8，依次和 {7} 比较，选出最小者7，交换，{1,2,4,6,7,8}

第六次选择：min = 8，其索引+1大于数组长度，退出内层循环，和自身交换，{1,2,4,6,7,8}

## 3、详细

	算法第四版
 
## 4、优缺点

	运行时间和输入无关：一个有序地数组和一个无序地数组所需时间一样长。

	数据移动次数最少：每次交换都会改变两个数组元素地值，因此用了N次交换

## 6、复杂度

	时间复杂度:
		平均情况：O(n^2) 
		最好情况：O(n^2) 
		最坏情况：O(n^2) 
    空间复杂度：O(1)

## 7、程序

```java
	private static void sort(int[] a){

		int n =a.length;
		for(int i=0;i<n;i++){
			int min=i;
			for(int j=i+1;j<n;j++){
				if(a[j]<a[min]) min=j;
			}
			exch(a,i,min);
		}
	}
```