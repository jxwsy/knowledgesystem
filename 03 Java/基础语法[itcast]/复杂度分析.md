# 复杂度分析

## 时间复杂度

	int aFunc(int n) {
	    for(int i = 0; i<n; i++) {         // 需要执行 (n + 1) 次
	        printf("Hello, World!\n");      // 需要执行 n 次
	    }
	    return 0;       // 需要执行 1 次
	}
	//这个方法需要 (n + 1 + n + 1) = 2n + 2 次运算。

	int aFunc(void) {
	    printf("Hello, World!\n");      //  需要执行 1 次
	    return 0;       // 需要执行 1 次
	}
	//那么上面这个方法需要执行 2 次运算

算法需要执行的运算次数 用 输入大小n 的函数 表示，即 T(n) .

**定义**： 存在常数 c，使得当 N >= c 时 T(N) <= f(N)，表示为 T(n) = O(f(n)) 。

![](https://i.imgur.com/rEuoWsN.jpg)

当 N >= 2 的时候，f(n) = n^2 总是大于 T(n) = n + 2 的，于是我们说 f(n) 的增长速度是大于或者等于 T(n) 的，也说 f(n) 是 T(n) 的上界，可以表示为 T(n) = O(f(n))。

算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。

如果 T(n) = n^2，那么 T(n) = O(n^2)，T(n) = O(n^3)，T(n) = O(n^4) 都是成立的，但是因为第一个 f(n) 的增长速度与 T(n) 是最接近的，所以第一个是最好的选择，所以我们说这个算法的复杂度是 O(n^2) 。

那么当我们拿到算法的执行次数函数 T(n) 之后怎么得到算法的时间复杂度呢？

	如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到
	函数 f(n)，此时算法的时间复杂度就是 O(f(n))。

**常见示例**

对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个
循环的时间复杂度为 O(n×m)。

	void aFunc(int n) {
	    for(int i = 0; i < n; i++) {         // 循环次数为 n
	        printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
	    }
	}

此时时间复杂度为 O(n × 1)，即 O(n)。

对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b,c...，则这个循环的时间复杂度为 O(n×a×b×c...)。分析的时候应该由里向外分析这些循环。

	void aFunc(int n) {
	    for(int i = 0; i < n; i++) {         // 循环次数为 n
	        for(int j = 0; j < n; j++) {       // 循环次数为 n
	            printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
	        }
	    }
	}

此时时间复杂度为 O(n × n × 1)，即 O(n^2)。

对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。

	void aFunc(int n) {
	    // 第一部分时间复杂度为 O(n^2)
	    for(int i = 0; i < n; i++) {
	        for(int j = 0; j < n; j++) {
	            printf("Hello, World!\n");
	        }
	    }
	    // 第二部分时间复杂度为 O(n)
	    for(int j = 0; j < n; j++) {
	        printf("Hello, World!\n");
	    }
	}

此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。

对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。

	void aFunc(int n) {
	    if (n >= 0) {
	        // 第一条路径时间复杂度为 O(n^2)
	        for(int i = 0; i < n; i++) {
	            for(int j = 0; j < n; j++) {
	                printf("输入数据大于等于零\n");
	            }
	        }
	    } else {
	        // 第二条路径时间复杂度为 O(n)
	        for(int j = 0; j < n; j++) {
	            printf("输入数据小于零\n");
	        }
	    }
	}

此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。

	int count = 1;
	while (count < n) {
	    count = count * 2;
	    /* 时间复杂度为 O(1) 的程序步骤序列 */
	}

由于每次 count 乘以 2 以后，就越来越接近于 n，也就是说有多少个 2 相乘后大于 n，则会退出循环。由 2x = n 等到 x = log2n。所以这个算法的时间复杂度为 T(n) = O(logn)

时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。

	https://www.jianshu.com/p/f4cca5ce055a

## 空间复杂度

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。

一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。

关于O(1)的问题，O(1)是说数据规模和临时变量数目无关，并不是说仅仅定义一个临时变量。举例：无论数据规模多大，我都定义100个变量，这就叫做数据规模和临时变量数目无关。就是说空间复杂度是O(1)。