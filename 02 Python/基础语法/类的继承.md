# 类的继承

英文官方文档: [https://docs.python.org/3.8/tutorial/classes.html](https://docs.python.org/3.8/tutorial/classes.html)

中文官方文档: [https://docs.python.org/zh-cn/3.8/tutorial/classes.html](https://docs.python.org/zh-cn/3.8/tutorial/classes.html)


[TOC]


## 1、继承

语法如下所示:

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

**BaseClassName 必须定义于包含派生类定义的作用域中。也允许用其他任意表达式代替基类名称所在的位置**。例如，当基类定义在另一个模块中的时候:

```python
class DerivedClassName(modname.BaseClassName):
```

派生类定义的执行过程与基类相同。

**如果请求的属性在类中找不到，搜索将转往基类中进行查找。如果基类本身也派生自其他某个类，则此规则将被递归地应用**。

派生类的实例化: `DerivedClassName()` 会创建该类的一个新实例。 

**派生类方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效**。【注：先在本类中找，没有的话在其父类中找】

派生类可能会重载其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。 

**在派生类中的重载方法实际上可能想要扩展而非简单地替换同名的基类方法**。 

直接调用基类方法：即调用 `BaseClassName.methodname(self, arguments)`。 有时这对客户端来说也是有用的。 （请注意仅当此基类可在全局作用域中以 `BaseClassName` 的名称被访问时方可使用此方式。）

Python有两个内置函数可被用于继承机制：

- **使用 [isinstance()](https://docs.python.org/zh-cn/3.8/library/functions.html#isinstance) 来检查一个实例的类型**: `isinstance(obj, int)` 仅会在 `obj.__class__` 为 [int](https://docs.python.org/zh-cn/3.8/library/functions.html#int) 或某个派生自 int 的类时为 True。

- **使用 [issubclass()](https://docs.python.org/zh-cn/3.8/library/functions.html#issubclass) 来检查类的继承关系**: `issubclass(bool, int)` 为 True，因为 [bool](https://docs.python.org/zh-cn/3.8/library/functions.html#bool) 是 int 的子类。 但是，`issubclass(float, int)` 为 False，因为 [float](https://docs.python.org/zh-cn/3.8/library/functions.html#float) 不是 int 的子类。

## 2、多重继承

```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```

**如果某一属性在 DerivedClassName 中未找到，则会到 Base1 中搜索它，然后（递归地）到 Base1 的基类中搜索，如果在那里未找到，再到 Base2 中搜索，依此类推**。当层次结构中存在重叠时不会在同一个类中搜索两次。

真实情况比这个更复杂一些；**方法解析顺序会动态改变，以支持对 [super()](https://docs.python.org/zh-cn/3.8/library/functions.html#super) 的协同调用**。这种方式在某些其他多重继承型语言中被称为**后续方法调用**，它比单继承型语言中的 `super` 调用更强大。

帮助理解: [https://www.cnblogs.com/miyauchi-renge/p/10923127.html](https://www.cnblogs.com/miyauchi-renge/p/10923127.html)

**动态改变顺序是有必要的**，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。 

例如，所有类都是继承自 [object](https://docs.python.org/zh-cn/3.8/library/functions.html#object)，因此任何多重继承的情况都提供了一条以上的路径可以通向 object。 


## 3、私有变量

那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。 

但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (如 `_spam`) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。

由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为 **名称改写**。 

任何形式为 `__spam` 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 `_classname__spam`，其中 classname 为去除了前缀下划线的当前类名称。

名称改写**有助于让子类重载父类方法而不破坏类内方法调用**。例如:

```python
class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)

    __update = update   # private copy of original update() method

class MappingSubclass(Mapping):

    def update(self, keys, values):
        # provides new signature for update()
        # but does not break __init__()
        for item in zip(keys, values):
            self.items_list.append(item)

#######################

# ms = MappingSubclass([1,2,3])
# ms.update([4,5],[6,7])
# print(ms.items_list)

# 输出：[1, 2, 3, (4, 6), (5, 7)]
```

对上面的示例，**即使在 MappingSubclass 引入了一个 `__update` 标识符的情况下也不会出错，因为它会在 Mapping 类中被替换为`_Mapping__update` ，而在 MappingSubclass 类中被替换为 `_MappingSubclass__update`**。【注：结合上面第四段理解】

请注意，**改写规则的设计主要是为了避免意外冲突；访问或修改被视为私有的变量仍然是可能的**。这在特殊情况下甚至会很有用，例如在调试器中。

请注意传递给 `exec()` 或 `eval()` 的代码不会将发起调用类的类名视作当前类；这类似于 `global` 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 `getattr()`, `setattr()` 和 `delattr()`，以及对于 `__dict__` 的直接引用。

## 4、杂项说明

有时会需要使用类似于 Pascal 的“record”或 C 的“struct”这样的数据类型，将一些命名数据项捆绑在一起。 这种情况适合定义一个空类:

```python
class Employee:
    pass

john = Employee()  # Create an empty employee record

# Fill the fields of the record
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
```

一段需要特定抽象数据类型的 Python 代码往往可以被传入一个模拟了该数据类型的方法的类作为替代。

例如，如果你有一个基于文件对象来格式化某些数据的函数，你可以定义一个带有 `read()` 和 `readline()` 方法从字符串缓存获取数据的类，并将其作为参数传入。

实例方法对象也具有属性: `m.__self__` 就是带有 `m()` 方法的实例对象，而 `m.__func__` 则是该方法所对应的函数对象。