# 索引02：索引策略

[TOC]

**高性能MySql第三版**

## 1、单独的列

即**索引列不能是表达式的一部分，也不能是函数的参数**。

应当简化where条件，将索引列单独放在比较符号的一侧。

```sql
MariaDB [mysql]> select * from webtest;                     
+----+--------------+---------------------------+-------+---------+
| id | name         | url                       | alexa | country |
+----+--------------+---------------------------+-------+---------+
|  1 | Google       | https://www.google.cm/    |     1 | USA     |
|  2 | 淘宝         | https://www.taobao.com/   |    13 | CN      |
|  3 | 菜鸟教程     | http://www.runoob.com/    |  4689 | CN      |
|  4 | 微博         | http://weibo.com/         |    20 | CN      |
|  5 | Facebook     | https://www.facebook.com/ |     3 | USA     |
+----+--------------+---------------------------+-------+---------+
5 rows in set (0.00 sec)

-- alexa列添加索引
MariaDB [mysql]> alter table webtest add index alexa_index(alexa);       
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [mysql]> desc webtest;
+---------+--------------+------+-----+---------+-------+
| Field   | Type         | Null | Key | Default | Extra |
+---------+--------------+------+-----+---------+-------+
| id      | int(11)      | NO   | PRI | 0       |       |
| name    | char(20)     | NO   |     |         |       |
| url     | varchar(255) | NO   |     |         |       |
| alexa   | int(11)      | NO   | MUL | 0       |       |
| country | char(10)     | NO   |     |         |       |
+---------+--------------+------+-----+---------+-------+

-- 查询方式1：索引字段表达式的一部分
MariaDB [mysql]> explain select * from webtest where alexa+1=3;
+------+-------------+---------+------+---------------+------+---------+------+------+-------------+
| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+------+-------------+---------+------+---------------+------+---------+------+------+-------------+
|    1 | SIMPLE      | webtest | ALL  | NULL          | NULL | NULL    | NULL |    5 | Using where |
+------+-------------+---------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.00 sec)

-- 查询方式2：索引字段作为函数参数
MariaDB [mysql]> explain select * from webtest where abs(alexa)=3;
+------+-------------+---------+------+---------------+------+---------+------+------+-------------+
| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+------+-------------+---------+------+---------------+------+---------+------+------+-------------+
|    1 | SIMPLE      | webtest | ALL  | NULL          | NULL | NULL    | NULL |    5 | Using where |
+------+-------------+---------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.00 sec)

-- 查询方式3：正常查询
MariaDB [mysql]> explain select * from webtest where alexa=3;     
+------+-------------+---------+------+---------------+-------------+---------+-------+------+-------+
| id   | select_type | table   | type | possible_keys | key         | key_len | ref   | rows | Extra |
+------+-------------+---------+------+---------------+-------------+---------+-------+------+-------+
|    1 | SIMPLE      | webtest | ref  | alexa_index   | alexa_index | 4       | const |    1 |       |
+------+-------------+---------+------+---------------+-------------+---------+-------+------+-------+
1 row in set (0.00 sec)
```

	可以看出：

		查询方式1和方式2的 type 字段均为 ALL，即全表查询。
		方式3为 ref，即访问索引，返回某个值的数据。

## 2、前缀索引和索引选择性

### 2.1、选择前缀长度

**索引的选择性**是：

	不重复的索引值（也称为基数）和数据表的总记录数的比值（#T），范围从1/#T到1之间。

	索引的选择性越高则查询效率越高，因为选择性高的索引可以让 mysql 在查找时过滤掉更多的行。

	唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

索引很长的列出现的问题是：让索引变得大且慢。

解决方法：

- 通过模拟哈希索引

- 索引的开始的部分字符【前缀索引】。可以节约索引空间，提高索引效率，但会降低索引的选择性。

一般情况下某个列的前缀索引的选择性也是足够高的，足以满足查询的性能。

**对于 BLOB、TEXT 或很长的 VARCHAR 类型的列，必须使用前缀索引**，因为 mysql 不允许索引这些列的完整长度。

选择诀窍是：前缀应该**足够长**，以使得前缀索引的选择性接近与索引整个列（换句话说，前缀的“基数”应该接近于完整列的“基数”），同时**又不能太长**（以便节约空间）。

为了决定前缀合适的长度，有以下两种方法：

先准备数据，生成示例表：

```sql
MariaDB [sakila]> create table sakila.city_demo(city varchar(50) not null);        
Query OK, 0 rows affected (0.00 sec)

MariaDB [sakila]> insert into sakila.city_demo(city) select city from sakila.city; 
Query OK, 600 rows affected (0.01 sec)
Records: 600  Duplicates: 0  Warnings: 0

MariaDB [sakila]> insert into sakila.city_demo(city) select city from sakila.city_demo; 
Query OK, 600 rows affected (0.01 sec)
Records: 600  Duplicates: 0  Warnings: 0

MariaDB [sakila]> update sakila.city_demo set city=(select city from sakila.city order by rand() limit 1);
Query OK, 1197 rows affected (0.41 sec)
Rows matched: 1200  Changed: 1197  Warnings: 0
```

【由于生成表时，用了rand()函数，所以，结果可能不一样】

**方法1：计算完整列的选择性**

```sql
MariaDB [sakila]> select count(distinct city)/count(*) from sakila.city_demo;                                                       
+-------------------------------+
| count(distinct city)/count(*) |
+-------------------------------+
|                        0.4392 |
+-------------------------------+
1 row in set (0.00 sec)

MariaDB [sakila]> select count(distinct left(city,3))/count(*) as sel3, count(distinct left(city,4))/count(*) as sel4, count(distinct left(city,5))/count(*) as sel5,  count(distinct left(city,6))/count(*) as sel6,  count(distinct left(city,7))/count(*) as sel7 from sakila.city_demo;
+--------+--------+--------+--------+--------+
| sel3   | sel4   | sel5   | sel6   | sel7   |
+--------+--------+--------+--------+--------+
| 0.3500 | 0.4167 | 0.4317 | 0.4375 | 0.4383 |
+--------+--------+--------+--------+--------+
1 row in set (0.00 sec)
```

计算结果越接近完整列的选择性越好。此例中，越接近0.4392越好。

计算结果显示当前缀超6个时，变化相比就不大了。所以可以选择6。【要看具体情况】

这种方法需要考虑**最坏情况下的选择性**，因为会出现数据分布不均的情况。

![index06](./image/index06.png)

**方法2：找到最常见的值的列表，然后和最常见的前缀列表进行比较**

```sql
-- 最常见的城市列表
MariaDB [sakila]> select count(*) as cnt,city from  sakila.city_demo group by city order by cnt desc limit 10;
+-----+--------------+
| cnt | city         |
+-----+--------------+
|   7 | London       |
|   7 | Masqat       |
|   6 | Sogamoso     |
|   6 | Ikerre       |
|   6 | Jos Azueta   |
|   6 | Dhaka        |
|   6 | Tarlac       |
|   6 | Soshanguve   |
|   6 | Phnom Penh   |
|   5 | Kakamigahara |
+-----+--------------+
10 rows in set (0.01 sec)

-- 最频繁出现的城市前缀，长度为3时
MariaDB [sakila]> select count(*) as cnt,left(city,3) as pref from sakila.city_demo group by pref order by cnt desc limit 10;
+-----+------+
| cnt | pref |
+-----+------+
|  20 | San  |
|  12 | al-  |
|  11 | Cha  |
|  10 | Kan  |
|  10 | Tar  |
|  10 | Man  |
|  10 | Sou  |
|   9 | Hal  |
|   9 | Tan  |
|   9 | Coa  |
+-----+------+
10 rows in set (0.00 sec)

-- 最频繁出现的城市前缀，长度为6时
MariaDB [sakila]> select count(*) as cnt,left(city,6) as pref from sakila.city_demo group by pref order by cnt desc limit 10; 
+-----+--------+
| cnt | pref   |
+-----+--------+
|   7 | London |
|   7 | Masqat |
|   6 | Phnom  |
|   6 | Sogamo |
|   6 | Dhaka  |
|   6 | Tarlac |
|   6 | Jos Az |
|   6 | Soshan |
|   6 | Ikerre |
|   5 | Cabuya |
+-----+--------+
10 rows in set (0.00 sec)
```

由上可知：**每个前缀都比原来的城市出现次数更多。所以需要增加前缀长度，直到前缀的选择性接近完整列的选择性。【如长度为6时】**


### 2.2、创建前缀索引

```sql
MariaDB [sakila]> alter table sakila.city_demo add key (city(6));
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [sakila]> explain select * from sakila.city_demo where city='Salamanca';
+------+-------------+-----------+------+---------------+------+---------+-------+------+-------------+
| id   | select_type | table     | type | possible_keys | key  | key_len | ref   | rows | Extra       |
+------+-------------+-----------+------+---------------+------+---------+-------+------+-------------+
|    1 | SIMPLE      | city_demo | ref  | city          | city | 8       | const |    4 | Using where |
+------+-------------+-----------+------+---------------+------+---------+-------+------+-------------+
1 row in set (0.00 sec)
```

### 2.3、优缺点

优点：

	使索引更小，更快。

缺点：

	mysql无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。【???】

### 2.4 适用场景

- 针对很长的十六进制唯一ID使用前缀索引

- 后缀索引也有用途（例如，找到某个域名的所有电子邮件地址）。mysql原生不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。

## 3、多列索引

对多列索引，一个常见的错误就是，为每个列创建独立的单列索引，或者按照错误的顺序创建多列索引。

在多个列上建立独立的索引大部分情况下并不能提高mysql的查询性能。

但是，mysql5.0和更新版引入了一种叫"索引合并"(index_merge)的策略，一定程度上可以使用表上的多个单列索引来定位指定的的行。

表 film_actor 在字段 actor_id 和 film_id 各有一个单列索引。

```sql
MariaDB [sakila]> explain select film_id,actor_id from sakila.film_actor where actor_id=1 or film_id=1;
+------+-------------+------------+-------------+------------------------+------------------------+---------+------+------+--------------------------------------------------+
| id   | select_type | table      | type        | possible_keys          | key                    | key_len | ref  | rows | Extra                                            |
+------+-------------+------------+-------------+------------------------+------------------------+---------+------+------+--------------------------------------------------+
|    1 | SIMPLE      | film_actor | index_merge | PRIMARY,idx_fk_film_id | PRIMARY,idx_fk_film_id | 2,2     | NULL |   29 | Using union(PRIMARY,idx_fk_film_id); Using where |
+------+-------------+------------+-------------+------------------------+------------------------+---------+------+------+--------------------------------------------------+
1 row in set (0.00 sec)
```

mysql 会使用这类技术优化复杂查询，所以实际上更多时候说明了表上的索引建的很糟糕：

- 当出现服务器对多个索引做相交操作时（多个AND），通常意味着需要一个包含相关列的多列索引，而不是多个独立的单列索引;

- 当服务器需要对多个索引做联合操作时（多个OR），通常需要耗费大量的CPU和内存在算法的缓存、排序和合并上。

- 优化器不会把这些计算到"查询成本"中，优化器只关心随机页面读取，使得查询的成本被低估,导致该执行计划还不如走全表扫描。这不仅会消耗更多的CPU和内存资源，还会影响查询的并发性。但如果单独运行这样的查询则会忽略对并发性的影响。所以该不如将查询改成union的方式

```sql
MariaDB [sakila]> select film_id,actor_id from sakila.film_actor where actor_id=1 union all select film_id,actor_id from sakila.film_actor where film_id=1 and actor_id<>1;
```

如果在 explain 中看到索引合并，应该好好检查一下查询和表的结构，看是不是已经是最优的。

也可以通过参数 optimizer_switch 来关闭索引合并功能。

也可以使用 IGNORE INDEX 提示让优化器忽略调某些索引。

--------------------------------------------------------------------------

mysql 5.1 中引入了 optimizer_switch，控制优化器行为。有一些结果集，通过on和off控制开启和关闭优化器行为。使用有效期全局和会话两个级别。

```sql
MariaDB [sakila]> select @@optimizer_switch;
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| @@optimizer_switch                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,index_merge_sort_intersection=off,engine_condition_pushdown=off,index_condition_pushdown=on,derived_merge=on,derived_with_keys=on,firstmatch=on,loosescan=on,materialization=on,in_to_exists=on,semijoin=on,partial_match_rowid_merge=on,partial_match_table_scan=on,subquery_cache=on,mrr=off,mrr_cost_based=off,mrr_sort_keys=off,outer_join_with_cache=on,semijoin_with_cache=on,join_cache_incremental=on,join_cache_hashed=on,join_cache_bka=on,optimize_join_buffer_size=off,table_elimination=on,extended_keys=off |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```
type类型是 index_merge（索引合并排序）。业务需要或滥建索引，数据表上会建很多索引。针对这个查询，可以通过修改optimizer_switch来优化优化器行为：

	set global optimizer_seitch="index_merge=off 

这个方式也行会有一定风险，影响其他sql，在服务器端操作要谨慎。  

[原文链接](https://blog.csdn.net/aeolus_pu/article/details/9120771)

--------------------------------------------------------------------------

使用ignore index()，这个指令可以强制Mysql在查询时，不使用某索引。

	SELECT * FROM TABLE1 IGNORE INDEX (FIELD1, FIELD2) …

--------------------------------------------------------------------------

## 4、选择合适的索引顺序

**本节内容适用于B-TREE索引**

索引列的正确顺序要考虑如下两个因素：

- 使用该索引的查询语句
- 如何更好的满足排序和分组的需求

在一个多列的B-Tree索引中，**索引列的顺序意味着索引先按照最左列排序，其次是第二列，等等**。所以，索引可以按照升序或降序扫描，以满足精确符合顺序的 ORDER BY 、 GROUP BY 、 DISTINCT 等子句的查询需求。【结合查询的三星系统理解】

![index02](./image/index02.png)

【看最后两个条目。`Allen Cuba 1960-01-01` 左边是字母顺序比 `Allen` 小的，这一侧 `last_name` 相同的情况下，比较`first_name`，依次往下。右边同理。】

### 4.1、如何选择合适的索引顺序

**将选择性最高的列放到索引最前列**【经验法则】

	适合不考虑排序和分组的场景，这时，索引只是优化了where条件的查找。

```sql
MariaDB [sakila]> select count(distinct staff_id)/count(*) from  payment;   
+-----------------------------------+
| count(distinct staff_id)/count(*) |
+-----------------------------------+
|                            0.0001 |
+-----------------------------------+
1 row in set (0.00 sec)

MariaDB [sakila]> select count(distinct customer_id)/count(*) from  payment;                      
+--------------------------------------+
| count(distinct customer_id)/count(*) |
+--------------------------------------+
|                               0.0373 |
+--------------------------------------+
1 row in set (0.01 sec)
```

customer_id 的选择性更高，所以将其作为第一列。



但，此时也要注意看**查询条件的具体值，即值的分布情况**。根据运行频率最高的查询调整索引列的顺序，让这种情况下索引的选择性更高。类似前面如何选择前缀长度。【选择一些值来尝试】

```sql
MariaDB [sakila]> select sum(staff_id=2),sum(customer_id=584) from  payment;
+-----------------+----------------------+
| sum(staff_id=2) | sum(customer_id=584) |
+-----------------+----------------------+
|            7992 |                   30 |
+-----------------+----------------------+
1 row in set (0.02 sec)
```
```sql
-- staff_id 选择性
MariaDB [sakila]> select count(distinct staff_id)/count(*) from  payment where staff_id=2;                                          
+-----------------------------------+
| count(distinct staff_id)/count(*) |
+-----------------------------------+
|                            0.0001 |
+-----------------------------------+
1 row in set (0.00 sec)

-- customer_id 选择性
MariaDB [sakila]> select count(distinct customer_id)/count(*) from  payment where customer_id=584;
+--------------------------------------+
| count(distinct customer_id)/count(*) |
+--------------------------------------+
|                               0.0333 |
+--------------------------------------+
1 row in set (0.00 sec)
```

根据前面的经验法则，应该将索引列 customer_id 放到最前面，因为对应条件值的 customer_id 数量更小。【数量小表示查询的快】

这种方式下【查询条件的具体值的方式】，**查询的结果非常依赖选定的具体值**。【因为你是按某个具体值调整的顺序，可能适用这个值，但不一定适用其他值】

按上述的示例做，会对其他条件值的查询不公平，服务器整体性能可能变糟，或其他某些查询的运行不如预期。

最后，尽管关于选择性和基数的经验法则值得去研究和分析，但**一定不要忘了WHERE子句中的排序、分组和范围条件等其他因素，这些因素可能对于查询的性能造成非常大的影响。**

## 5、聚簇索引

聚簇索引并不是一种单独的索引类型，而是**一种数据存储方式**。

**InnoDB的聚簇索引实际上在同一个结构中保存了B-TREE索引和数据**。

**当表有聚簇索引时，它的数据行存放在索引的叶子页。**

"聚簇"表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**。

因为是存储引擎负责实现，因此不是所有的存储引擎都支持聚簇索引。

这里我们主要关注的是InnoDB。

下图展示聚簇索引是如何存放记录的：【B树结构】

![index07](./image/index07.png)

上图中，叶子页包含了行的全部数据，但节点页只包含了索引列。这里，索引列包含的是整数值。

	InnoDB将通过主键聚集数据，这也就是说，上图中“被索引的列”就是主键。

	如果没有定义主键，InnoDB会选择一个唯一非空索引代替。

	如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

**InnoDB只聚集在同一个页面中的记录**。包含相邻键值的页面可能会相差很远。

### 5.1 聚集索引优点：

1）**可以把相关数据保存在一起**。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户的全部邮件。【用户ID作为索引列，按照上图组织数据】

2）**数据访问更快**。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中获取数据更快。

3）使用覆盖索引扫描的查询可以**直接使用页节点中的主键值**。（？？）

### 5.2 聚集索引缺点：

1）聚簇索引最大限度的提高了I/O密集型应用的性能，但**如果数据全部存放在内存**中，则访问的顺序就没那么重要了，聚簇索引也就没有什么优势了。

2）插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但**如果不是按照主键的顺序加载数据**，那么加载完数据后最好使用OPTIMIZE TABLE命令重新组织一下表。

3）**更新聚簇索引列的代价很高**，因为强制InnoDB将每个被更新的行移动到新的位置。

4）基于聚簇索引的表插入新行，或者主键被更新导致需要移动行的时候，可能**面临"页分裂"的问题**。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这是一次页分裂操作。

5）聚簇索引可能导致**全表扫描变慢**，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候

6）二级索引（非聚簇索引）可能比想象中的更大，因为二级索引的叶子节点包含了引用行的主键。

7）二级索引访问需要两次索引查找，而不是一次。

	二级索引保存的是行的主键值。
	存储引擎先找到二级索引的叶子节点，获取对应的主键值；再根据这个主键值去聚簇索引中查找对应的行。

	对于InnoDB，自适应哈希索引能减少这样的重复工作。

### 5.3 InnoDB和MyISAM数据分布对比(聚簇索引和二级索引进一步理解)

对于如下表：

	CREATE TABLE layout_test (
	  col1 int NOT NULL,
	  col2 int NOT NULL,
	  PRIMARY KEY(col1),
	  KEY(col2)
	);

col1：1-10000取值

col2：1-100随机取值

![index08](./image/index08.png)

#### 5.3.1、MyISAM

MyISAM按照插入的顺序在磁盘上存储数据

![index09](./image/index09.png)

![index10](./image/index10.png)

所以，在MyISAM中，主键索引和其它索引没有什么区别。主键索引仅仅只是一个叫做PRIMARY的唯一非空的索引而已。

#### 5.3.2、InnoDB

![index11](./image/index11.png)

在InnoDB中，聚簇索引"就是"表，所以不像MyISAM那样需要独立的行存储。

![index12](./image/index12.png)

InnoDB的二级索引的叶子节点中存储的是主键值，以此作为指向行的"指针"。这样的策略减小了当出现行移动或者数据页分裂时维护二级索引的维护工作。【结合前面缺点的第七条理解】

使用主键值当作指针会让二级索引占用更多空间，但是InnoDB在移动行时，无需更新二级索引中的这个"指针"。

![index13](./image/index13.png)

### 5.4、在InnoDB表中按主键顺序插入行

在表使用InnoDB做存储引擎时，应**使用自增的主键来作为聚集数据**。最好**避免随机的（不连续且值的分布范围非常大，比如UUID）聚簇索引**，特别时对于I/O密集型应用。

示例演示见pdf

## 6、覆盖索引

通常会根据查询的where条件来创建合适的索引，这只是索引优化的一个方向。设计优秀的索引应该考虑到整个查询，而不单单是where条件部分。

**索引是查找数据的高效方式，但MYSQL也可以使用索引来直接获取列的数据，这样就不需要再读取数据行。**

如果索引的叶子结点已经包含要查找的数据，就不需要再回表查询。(???)

**如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为"覆盖索引"**。

覆盖索引能够极大的提高性能。考虑一下如果查询只需要扫描索引而无须回表，通过会带来多少好处：

- **索引条目通常远小于数据行大小，所以如果只需要读取索引，那么mysql会极大的减少数据访问量，这对缓存的负载非常重要**。覆盖索引对于I/O密集型的应用也有帮助，因为所有比数据更小，更容易全部放入内存（这对MyISAM尤其正确，因为MyISAM能够压缩索引以使索引变得更小）。

- **因为索引是按照列值顺序存储的(至少在单个页内是如此)，所以对于I/O密集型的范围查询，会比随机从磁盘读取每一行数据的I/O要少得多**。对于某些存储引擎，例如MyISAM和Perconca XtraDB，甚至可以通过命令使得索引完全顺序排列，这让简单的范围查询可以使用完全顺序的索引访问。

- 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。

- 由于InnoDB的聚簇索引，覆盖索引对InnoDB特别有用。InnoDB的二级索引在叶子节点中保存行的主键值，所以**如果二级主键能覆盖查询，则可以避免对主键索引的二次查询。**

**不是所有类型的索引都可以成为覆盖索引，Mysql只能使用B-Tree索引做覆盖索引。**

不同的存储引擎实现覆盖索引的方式也不同，而且不是所有的引擎都支持覆盖索引。

当发起一个被索引覆盖的查询（也叫索引覆盖查询）时，在EXPLAIN的Extra列可以看到"Using index"的信息。

```sql
mysql> explain select store_id,film_id from sakila.inventory;
+----+-------------+-----------+------------+-------+---------------+----------------------+---------+------+------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys | key                  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-----------+------------+-------+---------------+----------------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | inventory | NULL       | index | NULL          | idx_store_id_film_id | 3       | NULL | 4581 |   100.00 | Using index |
+----+-------------+-----------+------------+-------+---------------+----------------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

注意：Extra列的"Using index"和type列的"index"是不同的。type列的"index"只是表示这个查询访问数据的方式。

索引覆盖查询还有很多陷阱可能会导致无法实现优化。mysql查询优化器会执行查询前判断是否有一个索引能进行覆盖。**假设覆盖了where条件中的字段，但不是整个查询涉及的字段。如果条件为false，mysql5.5和更早版本也总是会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。**

来看看为什么会发生这样的情况，以及如何重写查询以解决该问题。从下面的查询开始：

![index14](./image/index14.png)

 这里索引无法覆盖查询，有两个原因：

- 没有任何索引能够覆盖这个查询。**因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。**不过，理论上mysql还有一条捷径可以利用：where条件中的列是有索引可以覆盖的，因此mysql可以利用该索引找到对应的actor并检查title是否匹配，过滤之后再读取需要的数据行。

- **mysql不能在索引中执行like操作**，这是底层存储引擎API的限制。mysql只能再索引中做最左前缀匹配的like比较。

也有办法可以解决上面的问题，需要重写查询并巧妙的设计索引。先将索引扩展至覆盖三个数据列（artist,title,prod_id），然后按如下方式重写查询：

![index15](./image/index15.png)

把这种方式叫做延迟关联，因为延迟了对列的访问。

在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的查询。不过，可以进一步优化InnoDB。InnoDB的二级索引的叶子结点都包含了主键的值，这意味着InnoDB的二级索引可以有效利用这些额外的主键列来覆盖查询。

例如，sakila.actor使用InnoDB存储引擎，并在last_name字段有二级索引，虽然该索引的列不包括主键actor_id，但也能用于对actor_id做覆盖查询。

![index16](./image/index16.png)

## 7、使用索引扫描来做排序
